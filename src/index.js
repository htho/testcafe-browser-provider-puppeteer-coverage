// @ts-check
import puppeteer from 'puppeteer';
import puppeteerToIstanbul from 'puppeteer-to-istanbul';
import { writeFileSync } from "fs";

export default {
  isMultiBrowser: true,

  /** @type {puppeteer.Browser | null} */
  browser: null,

  /** @type {Record<string, puppeteer.Page>} */
  openedPages: {},

  /** Runs the specified browser and opens the specified page in it.
   * 
   * required by TestCafe
   * 
   * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
   * The identifier is included to the window title exposed using the `document.title` property.
   * @param {string} pageUrl The url of the page to open.
   * @param {string} browserName The browser name.
   */
  async openBrowser(id, pageUrl, browserName) {
    const browserArgs = browserName.split(':');
    if (!this.browser) {
      const launchArgs = {
        timeout: 10000
      };

      const noSandboxArgs = ['--no-sandbox', '--disable-setuid-sandbox'];

      if (browserArgs.indexOf('no_sandbox') !== -1) launchArgs.args = noSandboxArgs;
      else if (browserName.indexOf('?') !== -1) {
        const userArgs = browserName.split('?');
        const params = userArgs[0];

        if (params === 'no_sandbox') launchArgs.args = noSandboxArgs;

        const executablePath = userArgs[1];

        if (executablePath.length > 0)
          launchArgs.executablePath = executablePath;
      }
      this.browser = await puppeteer.launch(launchArgs);
    }

    const page = await this.browser.newPage();

    const emulationArg = browserArgs.find(v => /^emulate/.test(v));

    if (Boolean(emulationArg)) {
      const [, emulationDevice] = emulationArg.split('=');
      const device = puppeteer.devices[emulationDevice];

      if (!device) throw new Error('Emulation device is not supported');

      await page.emulate(device);
    }

    await this._startCoverage(page);

    await page.goto(pageUrl);
    this.openedPages[id] = page;
  },

  /** Closes the specified browser. 
   * 
   * required by TestCafe
   * 
   * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
   */
  async closeBrowser(id) {
    const page = this.openedPages[id];

    try {
      await this._stopCoverage(page);
    } catch (error) {
      console.debug(error);
    }

    delete this.openedPages[id];
    await this.browser?.close();
  },

  async isValidBrowserName() {
    return true;
  },

  /** Checks if the browser window can be resized to the specified dimensions.
   * 
   * optional extra for TestCafe
   * 
   * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
   * @param {number} width The desired width of the browser window's client area, in pixels.
   * @param {number} height The desired height of the browser window's client area, in pixels.
   * 
   * @returns {Promise<boolean>} true if the window can be resized to the specified width and height, or false otherwise.
   */
  async resizeWindow(id, width, height) {
    await this.openedPages[id].setViewport({ width, height });
    return true;
  },

  /** Takes a screenshot of the browser window's client area.
   * 
   * optional extra for TestCafe
   * 
   * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
   * @param {string} screenshotPath The directory path to save the screenshots to.
   * @param {number} [_pageWidth] The actual width of the web page opened in the browser, in pixels.
   * @param {number} [_pageHeight] The actual height of the web page opened in the browser, in pixels.
   */
  async takeScreenshot(id, screenshotPath, _pageWidth, _pageHeight) {
    await this.openedPages[id].screenshot({ path: screenshotPath });
  },

  /**
   * @param {puppeteer.Page} page 
   */
  async _startCoverage(page) {
    await Promise.all([
      page.coverage.startJSCoverage({ reportAnonymousScripts: false, resetOnNavigation: false, includeRawScriptCoverage: true }),
      page.coverage.startCSSCoverage({ resetOnNavigation: false }),
    ]);
  },

  /**
   * @param {puppeteer.Page} page 
   */
  async _stopCoverage(page) {
    const jsCoverage = await this._processCoverage((await page.coverage.stopJSCoverage()), ".js");
    const cssCoverage = await this._processCoverage((await page.coverage.stopCSSCoverage()), ".css");

    // writeFileSync('jsCoverage.json', JSON.stringify(jsCoverage));
    // writeFileSync('cssCoverage.json', JSON.stringify(cssCoverage));

    puppeteerToIstanbul.write([...jsCoverage, ...cssCoverage], { includeHostname: false, storagePath: './.nyc_output/', });
  },

  /**
   * @param {puppeteer.CoverageEntry[]} coverage 
   * @param {".js" | ".css"} ending 
   * @return {Promise<puppeteer.CoverageEntry[]>} 
   */
  async _processCoverage(coverage, ending) {
    const urlsOfTestedFiles = coverage.filter(entry => this._isUrlOfTestedFile(entry.url));

    /** @type {puppeteer.CoverageEntry[]} */
    const cleanFiles = urlsOfTestedFiles
      .map((file) => this._removeHammerHeadFromTestedFile(file))
      .map((file) => this._forceIndexFile(file, ending));

    return cleanFiles;
  },

  /**
   * @param {puppeteer.CoverageEntry} file 
   * @return {puppeteer.CoverageEntry} 
   */
  _removeHammerHeadFromTestedFile(file) {
    const url = this._extractUrlOfTestedCode(file.url);
    const text = this._removeHammerHeadHeader(file.text);
    const offset = file.text.indexOf(text);

    const ranges = file.ranges
      .map(({ start, end }) => ({ start: start - offset, end: end - offset }))
      .map(({ start, end }) => ({ start: Math.max(start, 0), end: Math.max(end, 0) }))
      .map(({ start, end }) => ({ start: Math.min(start, text.length - 1), end: Math.min(end, text.length - 1) }))
      .filter(({ start, end }) => start !== end);

    return {
      url,
      text,
      ranges
    };
  },
  
  /**
   * @param {puppeteer.CoverageEntry} file 
   * @param {".js" | ".css"} ending 
   * @return {puppeteer.CoverageEntry} 
   */
  _forceIndexFile({ url, ranges, text }, ending) {
    return {
      url: url.endsWith("/") ? url + "index" + ending : url,
      ranges,
      text
    };
  },

  /**
   * @param {string} url 
   * @returns {string}
   */
  _extractUrlOfTestedCode(url) {
    const regex = /^https?:\/\/.*?(https?:\/\/.*)/;
    const result = regex.exec(url);
    if (!result) throw new Error(`Unexpected URL: ${url}`);
    return result[1];
  },

  /**
   * @param {string} url 
   * @returns {boolean}
   */
  _isUrlOfTestedFile(url) {
    const regex = /^https?:\/\/.*?(https?:\/\/.*)/;
    return regex.test(url);
  },

  /**
   * extracted from:
   * https://github.com/DevExpress/testcafe-hammerhead/blob/4751c9fd97df3e4a0d505cc909cbd191fd1d227a/src/utils/regexp-escape.ts
   */
  _reEscape(str = '') {
    return str.replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
  },

  /**
   * extracted from: 
   * https://github.com/DevExpress/testcafe-hammerhead/blob/4751c9fd97df3e4a0d505cc909cbd191fd1d227a/src/processing/script/header.ts
   */
  _removeHammerHeadHeader(text = '') {
    const SCRIPT_PROCESSING_START_COMMENT = '/*hammerhead|script|start*/';
    const SCRIPT_PROCESSING_END_COMMENT = '/*hammerhead|script|end*/';
    const SCRIPT_PROCESSING_END_HEADER_COMMENT = '/*hammerhead|script|processing-header-end*/';
    const HEADER_RE = new RegExp(`${this._reEscape(SCRIPT_PROCESSING_START_COMMENT)}[\\S\\s]+?${this._reEscape(SCRIPT_PROCESSING_END_HEADER_COMMENT)}\n?`, 'gi');
    const PROCESSING_END_COMMENT_RE = new RegExp(`\n?${this._reEscape(SCRIPT_PROCESSING_END_COMMENT)}\\s*`, 'gi');

    return text.replace(HEADER_RE, '').replace(PROCESSING_END_COMMENT_RE, '');
    }
};

