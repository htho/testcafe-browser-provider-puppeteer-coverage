"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _puppeteer = _interopRequireWildcard(require("puppeteer"));
var _puppeteerToIstanbul = _interopRequireDefault(require("puppeteer-to-istanbul"));
var _fs = require("fs");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// @ts-check
var _default = {
  isMultiBrowser: true,
  /** @type {puppeteer.Browser | null} */
  browser: null,
  /** @type {Record<string, puppeteer.Page>} */
  openedPages: {},
  /** Runs the specified browser and opens the specified page in it.
   * 
   * required by TestCafe
   * 
   * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
   * The identifier is included to the window title exposed using the `document.title` property.
   * @param {string} pageUrl The url of the page to open.
   * @param {string} browserName The browser name.
   */
  openBrowser: function openBrowser(id, pageUrl, browserName) {
    var _this = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
      var browserArgs, launchArgs, noSandboxArgs, userArgs, params, executablePath, page, emulationArg, _emulationArg$split, _emulationArg$split2, emulationDevice, device;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              browserArgs = browserName.split(':');
              if (_this.browser) {
                _context.next = 8;
                break;
              }
              launchArgs = {
                timeout: 10000
              };
              noSandboxArgs = ['--no-sandbox', '--disable-setuid-sandbox'];
              if (browserArgs.indexOf('no_sandbox') !== -1) launchArgs.args = noSandboxArgs;else if (browserName.indexOf('?') !== -1) {
                userArgs = browserName.split('?');
                params = userArgs[0];
                if (params === 'no_sandbox') launchArgs.args = noSandboxArgs;
                executablePath = userArgs[1];
                if (executablePath.length > 0) launchArgs.executablePath = executablePath;
              }
              _context.next = 7;
              return _puppeteer["default"].launch(launchArgs);
            case 7:
              _this.browser = _context.sent;
            case 8:
              _context.next = 10;
              return _this.browser.newPage();
            case 10:
              page = _context.sent;
              emulationArg = browserArgs.find(function (v) {
                return /^emulate/.test(v);
              });
              if (!Boolean(emulationArg)) {
                _context.next = 19;
                break;
              }
              _emulationArg$split = emulationArg.split('='), _emulationArg$split2 = (0, _slicedToArray2["default"])(_emulationArg$split, 2), emulationDevice = _emulationArg$split2[1];
              device = _puppeteer.KnownDevices[emulationDevice];
              if (device) {
                _context.next = 17;
                break;
              }
              throw new Error('Emulation device is not supported');
            case 17:
              _context.next = 19;
              return page.emulate(device);
            case 19:
              _context.next = 21;
              return _this._startCoverage(page);
            case 21:
              _context.next = 23;
              return page["goto"](pageUrl);
            case 23:
              _this.openedPages[id] = page;
            case 24:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  /** Closes the specified browser. 
   * 
   * required by TestCafe
   * 
   * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
   */
  closeBrowser: function closeBrowser(id) {
    var _this2 = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
      var _this2$browser;
      var page;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              page = _this2.openedPages[id];
              _context2.next = 3;
              return _this2._stopCoverage(page);
            case 3:
              // try {
              // } catch (error) {
              //   console.debug(error);
              // }

              delete _this2.openedPages[id];
              _context2.next = 6;
              return (_this2$browser = _this2.browser) === null || _this2$browser === void 0 ? void 0 : _this2$browser.close();
            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }))();
  },
  isValidBrowserName: function isValidBrowserName() {
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", true);
            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }))();
  },
  /** Checks if the browser window can be resized to the specified dimensions.
   * 
   * optional extra for TestCafe
   * 
   * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
   * @param {number} width The desired width of the browser window's client area, in pixels.
   * @param {number} height The desired height of the browser window's client area, in pixels.
   * 
   * @returns {Promise<boolean>} true if the window can be resized to the specified width and height, or false otherwise.
   */
  resizeWindow: function resizeWindow(id, width, height) {
    var _this3 = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return _this3.openedPages[id].setViewport({
                width: width,
                height: height
              });
            case 2:
              return _context4.abrupt("return", true);
            case 3:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }))();
  },
  /** Takes a screenshot of the browser window's client area.
   * 
   * optional extra for TestCafe
   * 
   * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
   * @param {string} screenshotPath The directory path to save the screenshots to.
   * @param {number} [_pageWidth] The actual width of the web page opened in the browser, in pixels.
   * @param {number} [_pageHeight] The actual height of the web page opened in the browser, in pixels.
   */
  takeScreenshot: function takeScreenshot(id, screenshotPath, _pageWidth, _pageHeight) {
    var _this4 = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
      return _regenerator["default"].wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return _this4.openedPages[id].screenshot({
                path: screenshotPath
              });
            case 2:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }))();
  },
  /**
   * @param {puppeteer.Page} page 
   */
  _startCoverage: function _startCoverage(page) {
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
      return _regenerator["default"].wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return Promise.all([page.coverage.startJSCoverage({
                reportAnonymousScripts: false,
                resetOnNavigation: false,
                includeRawScriptCoverage: true
              }), page.coverage.startCSSCoverage({
                resetOnNavigation: false
              })]);
            case 2:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }))();
  },
  /**
   * @param {puppeteer.Page} page 
   */
  _stopCoverage: function _stopCoverage(page) {
    var _this5 = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7() {
      var jsCoverage, cssCoverage;
      return _regenerator["default"].wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.t0 = _this5;
              _context7.next = 3;
              return page.coverage.stopJSCoverage();
            case 3:
              _context7.t1 = _context7.sent;
              _context7.next = 6;
              return _context7.t0._processCoverage.call(_context7.t0, _context7.t1, ".js");
            case 6:
              jsCoverage = _context7.sent;
              _context7.t2 = _this5;
              _context7.next = 10;
              return page.coverage.stopCSSCoverage();
            case 10:
              _context7.t3 = _context7.sent;
              _context7.next = 13;
              return _context7.t2._processCoverage.call(_context7.t2, _context7.t3, ".css");
            case 13:
              cssCoverage = _context7.sent;
              // writeFileSync('jsCoverage.json', JSON.stringify(jsCoverage));
              // writeFileSync('cssCoverage.json', JSON.stringify(cssCoverage));

              _puppeteerToIstanbul["default"].write([].concat((0, _toConsumableArray2["default"])(jsCoverage), (0, _toConsumableArray2["default"])(cssCoverage)), {
                includeHostname: false,
                storagePath: './.nyc_output/'
              });
            case 15:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }))();
  },
  /**
   * @param {puppeteer.CoverageEntry[]} coverage 
   * @param {".js" | ".css"} ending 
   * @return {Promise<puppeteer.CoverageEntry[]>} 
   */
  _processCoverage: function _processCoverage(coverage, ending) {
    var _this6 = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8() {
      var urlsOfTestedFiles, cleanFiles;
      return _regenerator["default"].wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              urlsOfTestedFiles = coverage.filter(function (entry) {
                return _this6._isUrlOfTestedFile(entry.url);
              });
              /** @type {puppeteer.CoverageEntry[]} */
              cleanFiles = urlsOfTestedFiles.map(function (file) {
                return _this6._removeHammerHeadFromTestedFile(file);
              }).map(function (file) {
                return _this6._forceIndexFile(file, ending);
              });
              return _context8.abrupt("return", cleanFiles);
            case 3:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }))();
  },
  /**
   * @param {puppeteer.CoverageEntry} file 
   * @return {puppeteer.CoverageEntry} 
   */
  _removeHammerHeadFromTestedFile: function _removeHammerHeadFromTestedFile(file) {
    var url = this._extractUrlOfTestedCode(file.url);
    var text = this._removeHammerHeadHeader(file.text);
    var offset = file.text.indexOf(text);
    var ranges = file.ranges.map(function (_ref) {
      var start = _ref.start,
        end = _ref.end;
      return {
        start: start - offset,
        end: end - offset
      };
    }).map(function (_ref2) {
      var start = _ref2.start,
        end = _ref2.end;
      return {
        start: Math.max(start, 0),
        end: Math.max(end, 0)
      };
    }).map(function (_ref3) {
      var start = _ref3.start,
        end = _ref3.end;
      return {
        start: Math.min(start, text.length - 1),
        end: Math.min(end, text.length - 1)
      };
    }).filter(function (_ref4) {
      var start = _ref4.start,
        end = _ref4.end;
      return start !== end;
    });
    return {
      url: url,
      text: text,
      ranges: ranges
    };
  },
  /**
   * @param {puppeteer.CoverageEntry} file 
   * @param {".js" | ".css"} ending 
   * @return {puppeteer.CoverageEntry} 
   */
  _forceIndexFile: function _forceIndexFile(_ref5, ending) {
    var url = _ref5.url,
      ranges = _ref5.ranges,
      text = _ref5.text;
    return {
      url: url.endsWith("/") ? url + "index" + ending : url,
      ranges: ranges,
      text: text
    };
  },
  /**
   * @param {string} url 
   * @returns {string}
   */
  _extractUrlOfTestedCode: function _extractUrlOfTestedCode(url) {
    var regex = /^https?:\/\/.*?(https?:\/\/.*)/;
    var result = regex.exec(url);
    if (!result) throw new Error("Unexpected URL: ".concat(url));
    return result[1];
  },
  /**
   * @param {string} url 
   * @returns {boolean}
   */
  _isUrlOfTestedFile: function _isUrlOfTestedFile(url) {
    var regex = /^https?:\/\/.*?(https?:\/\/.*)/;
    return regex.test(url);
  },
  /**
   * extracted from:
   * https://github.com/DevExpress/testcafe-hammerhead/blob/4751c9fd97df3e4a0d505cc909cbd191fd1d227a/src/utils/regexp-escape.ts
   */
  _reEscape: function _reEscape() {
    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return str.replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
  },
  /**
   * extracted from: 
   * https://github.com/DevExpress/testcafe-hammerhead/blob/4751c9fd97df3e4a0d505cc909cbd191fd1d227a/src/processing/script/header.ts
   */
  _removeHammerHeadHeader: function _removeHammerHeadHeader() {
    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var SCRIPT_PROCESSING_START_COMMENT = '/*hammerhead|script|start*/';
    var SCRIPT_PROCESSING_END_COMMENT = '/*hammerhead|script|end*/';
    var SCRIPT_PROCESSING_END_HEADER_COMMENT = '/*hammerhead|script|processing-header-end*/';
    var HEADER_RE = new RegExp("".concat(this._reEscape(SCRIPT_PROCESSING_START_COMMENT), "[\\S\\s]+?").concat(this._reEscape(SCRIPT_PROCESSING_END_HEADER_COMMENT), "\n?"), 'gi');
    var PROCESSING_END_COMMENT_RE = new RegExp("\n?".concat(this._reEscape(SCRIPT_PROCESSING_END_COMMENT), "\\s*"), 'gi');
    return text.replace(HEADER_RE, '').replace(PROCESSING_END_COMMENT_RE, '');
  }
};
exports["default"] = _default;
module.exports = exports.default;