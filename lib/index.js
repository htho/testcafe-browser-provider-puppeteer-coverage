"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _puppeteer = _interopRequireDefault(require("puppeteer"));
var _puppeteerToIstanbul = _interopRequireDefault(require("puppeteer-to-istanbul"));
var _sourceMap = _interopRequireWildcard(require("source-map"));
var _fs = require("fs");
var _fetch = require("fetch");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var _default = {
  isMultiBrowser: true,
  /** @type {puppeteer.Browser | null} */
  browser: null,
  /** @type {Record<string, puppeteer.Page>} */
  openedPages: {},
  /** Runs the specified browser and opens the specified page in it.
   * 
   * required by TestCafe
   * 
   * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
   * The identifier is included to the window title exposed using the `document.title` property.
   * @param {string} pageUrl The url of the page to open.
   * @param {string} browserName The browser name.
   */
  openBrowser: function openBrowser(id, pageUrl, browserName) {
    var _this = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
      var browserArgs, launchArgs, noSandboxArgs, userArgs, params, executablePath, page, emulationArg, _emulationArg$split, _emulationArg$split2, emulationDevice, device;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              browserArgs = browserName.split(':');
              if (_this.browser) {
                _context.next = 8;
                break;
              }
              launchArgs = {
                timeout: 10000
              };
              noSandboxArgs = ['--no-sandbox', '--disable-setuid-sandbox'];
              if (browserArgs.indexOf('no_sandbox') !== -1) launchArgs.args = noSandboxArgs;else if (browserName.indexOf('?') !== -1) {
                userArgs = browserName.split('?');
                params = userArgs[0];
                if (params === 'no_sandbox') launchArgs.args = noSandboxArgs;
                executablePath = userArgs[1];
                if (executablePath.length > 0) launchArgs.executablePath = executablePath;
              }
              _context.next = 7;
              return _puppeteer["default"].launch(launchArgs);
            case 7:
              _this.browser = _context.sent;
            case 8:
              _context.next = 10;
              return _this.browser.newPage();
            case 10:
              page = _context.sent;
              emulationArg = browserArgs.find(function (v) {
                return /^emulate/.test(v);
              });
              if (!Boolean(emulationArg)) {
                _context.next = 19;
                break;
              }
              _emulationArg$split = emulationArg.split('='), _emulationArg$split2 = (0, _slicedToArray2["default"])(_emulationArg$split, 2), emulationDevice = _emulationArg$split2[1];
              device = _puppeteer["default"].devices[emulationDevice];
              if (device) {
                _context.next = 17;
                break;
              }
              throw new Error('Emulation device is not supported');
            case 17:
              _context.next = 19;
              return page.emulate(device);
            case 19:
              _context.next = 21;
              return _this._startCoverage(page);
            case 21:
              _context.next = 23;
              return page["goto"](pageUrl);
            case 23:
              _this.openedPages[id] = page;
            case 24:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  /** Closes the specified browser. 
   * 
   * required by TestCafe
   * 
   * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
   */
  closeBrowser: function closeBrowser(id) {
    var _this2 = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
      var _this2$browser;
      var page;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              page = _this2.openedPages[id];
              _context2.prev = 1;
              _context2.next = 4;
              return _this2._stopCoverage(page);
            case 4:
              _context2.next = 9;
              break;
            case 6:
              _context2.prev = 6;
              _context2.t0 = _context2["catch"](1);
              console.debug(_context2.t0);
            case 9:
              delete _this2.openedPages[id];
              _context2.next = 12;
              return (_this2$browser = _this2.browser) === null || _this2$browser === void 0 ? void 0 : _this2$browser.close();
            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[1, 6]]);
    }))();
  },
  isValidBrowserName: function isValidBrowserName() {
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", true);
            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }))();
  },
  /** Checks if the browser window can be resized to the specified dimensions.
   * 
   * optional extra for TestCafe
   * 
   * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
   * @param {number} width The desired width of the browser window's client area, in pixels.
   * @param {number} height The desired height of the browser window's client area, in pixels.
   * 
   * @returns {Promise<boolean>} true if the window can be resized to the specified width and height, or false otherwise.
   */
  resizeWindow: function resizeWindow(id, width, height) {
    var _this3 = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return _this3.openedPages[id].setViewport({
                width: width,
                height: height
              });
            case 2:
              return _context4.abrupt("return", true);
            case 3:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }))();
  },
  /** Takes a screenshot of the browser window's client area.
   * 
   * optional extra for TestCafe
   * 
   * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
   * @param {string} screenshotPath The directory path to save the screenshots to.
   * @param {number} [_pageWidth] The actual width of the web page opened in the browser, in pixels.
   * @param {number} [_pageHeight] The actual height of the web page opened in the browser, in pixels.
   */
  takeScreenshot: function takeScreenshot(id, screenshotPath, _pageWidth, _pageHeight) {
    var _this4 = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
      return _regenerator["default"].wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return _this4.openedPages[id].screenshot({
                path: screenshotPath
              });
            case 2:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }))();
  },
  /**
   * @param {puppeteer.Page} page 
   */
  _startCoverage: function _startCoverage(page) {
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
      return _regenerator["default"].wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return Promise.all([page.coverage.startJSCoverage({
                reportAnonymousScripts: false,
                resetOnNavigation: false,
                includeRawScriptCoverage: true
              }), page.coverage.startCSSCoverage({
                resetOnNavigation: false
              })]);
            case 2:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }))();
  },
  /**
   * @param {puppeteer.Page} page 
   */
  _stopCoverage: function _stopCoverage(page) {
    var _this5 = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7() {
      var jsCoverage, cssCoverage;
      return _regenerator["default"].wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.t0 = _this5;
              _context7.next = 3;
              return page.coverage.stopJSCoverage();
            case 3:
              _context7.t1 = _context7.sent;
              _context7.next = 6;
              return _context7.t0._processCoverage.call(_context7.t0, _context7.t1, ".js");
            case 6:
              jsCoverage = _context7.sent;
              _context7.t2 = _this5;
              _context7.next = 10;
              return page.coverage.stopCSSCoverage();
            case 10:
              _context7.t3 = _context7.sent;
              _context7.next = 13;
              return _context7.t2._processCoverage.call(_context7.t2, _context7.t3, ".css");
            case 13:
              cssCoverage = _context7.sent;
              // writeFileSync('jsCoverage.json', JSON.stringify(jsCoverage));
              // writeFileSync('cssCoverage.json', JSON.stringify(cssCoverage));

              _puppeteerToIstanbul["default"].write([].concat((0, _toConsumableArray2["default"])(jsCoverage), (0, _toConsumableArray2["default"])(cssCoverage)), {
                includeHostname: false,
                storagePath: './.nyc_output/'
              });
            case 15:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }))();
  },
  /**
   * @param {puppeteer.CoverageEntry[]} coverage 
   * @param {".js" | ".css"} ending 
   * @return {Promise<puppeteer.CoverageEntry[]>} 
   */
  _processCoverage: function _processCoverage(coverage, ending) {
    var _this6 = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8() {
      var urlsOfTestedFiles, cleanFiles, resolvedSourceMaps;
      return _regenerator["default"].wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              urlsOfTestedFiles = coverage.filter(function (entry) {
                return _this6._isUrlOfTestedFile(entry.url);
              });
              /** @type {puppeteer.CoverageEntry[]} */
              cleanFiles = urlsOfTestedFiles.map(function (file) {
                return _this6._removeHammerHeadFromTestedFile(file);
              }).map(function (file) {
                return _this6._forceIndexFile(file, ending);
              });
              return _context8.abrupt("return", cleanFiles);
            case 5:
              resolvedSourceMaps = _context8.sent;
              return _context8.abrupt("return", resolvedSourceMaps.flat().filter(_this6._isDefined));
            case 7:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }))();
  },
  /**
   * @param {puppeteer.CoverageEntry} file 
   * @return {puppeteer.CoverageEntry} 
   */
  _removeHammerHeadFromTestedFile: function _removeHammerHeadFromTestedFile(file) {
    var url = this._extractUrlOfTestedCode(file.url);
    var text = this._removeHammerHeadHeader(file.text);
    var offset = file.text.indexOf(text);
    var ranges = file.ranges.map(function (_ref) {
      var start = _ref.start,
        end = _ref.end;
      return {
        start: start - offset,
        end: end - offset
      };
    }).map(function (_ref2) {
      var start = _ref2.start,
        end = _ref2.end;
      return {
        start: Math.max(start, 0),
        end: Math.max(end, 0)
      };
    }).map(function (_ref3) {
      var start = _ref3.start,
        end = _ref3.end;
      return {
        start: Math.min(start, text.length - 1),
        end: Math.min(end, text.length - 1)
      };
    }).filter(function (_ref4) {
      var start = _ref4.start,
        end = _ref4.end;
      return start !== end;
    });
    return {
      url: url,
      text: text,
      ranges: ranges
    };
  },
  /**
   * @param {puppeteer.CoverageEntry} file 
   * @param {".js" | ".css"} ending 
   * @return {puppeteer.CoverageEntry} 
   */
  _forceIndexFile: function _forceIndexFile(_ref5, ending) {
    var url = _ref5.url,
      ranges = _ref5.ranges,
      text = _ref5.text;
    return {
      url: url.endsWith("/") ? url + "index" + ending : url,
      ranges: ranges,
      text: text
    };
  },
  /**
   * @param {string} url 
   * @returns {string}
   */
  _extractUrlOfTestedCode: function _extractUrlOfTestedCode(url) {
    var regex = /^https?:\/\/.*?(https?:\/\/.*)/;
    var result = regex.exec(url);
    if (!result) throw new Error("Unexpected URL: ".concat(url));
    return result[1];
  },
  /**
   * @param {string} url 
   * @returns {boolean}
   */
  _isUrlOfTestedFile: function _isUrlOfTestedFile(url) {
    var regex = /^https?:\/\/.*?(https?:\/\/.*)/;
    return regex.test(url);
  },
  /**
   * extracted from:
   * https://github.com/DevExpress/testcafe-hammerhead/blob/4751c9fd97df3e4a0d505cc909cbd191fd1d227a/src/utils/regexp-escape.ts
   */
  _reEscape: function _reEscape() {
    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return str.replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
  },
  /**
   * extracted from: 
   * https://github.com/DevExpress/testcafe-hammerhead/blob/4751c9fd97df3e4a0d505cc909cbd191fd1d227a/src/processing/script/header.ts
   */
  _removeHammerHeadHeader: function _removeHammerHeadHeader() {
    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var SCRIPT_PROCESSING_START_COMMENT = '/*hammerhead|script|start*/';
    var SCRIPT_PROCESSING_END_COMMENT = '/*hammerhead|script|end*/';
    var SCRIPT_PROCESSING_END_HEADER_COMMENT = '/*hammerhead|script|processing-header-end*/';
    var HEADER_RE = new RegExp("".concat(this._reEscape(SCRIPT_PROCESSING_START_COMMENT), "[\\S\\s]+?").concat(this._reEscape(SCRIPT_PROCESSING_END_HEADER_COMMENT), "\n?"), 'gi');
    var PROCESSING_END_COMMENT_RE = new RegExp("\n?".concat(this._reEscape(SCRIPT_PROCESSING_END_COMMENT), "\\s*"), 'gi');
    return text.replace(HEADER_RE, '').replace(PROCESSING_END_COMMENT_RE, '');
  },
  /**
   * @param {puppeteer.CoverageEntry} bundle 
   * @return {Promise<puppeteer.CoverageEntry[] | undefined>}
   */
  _resolveSourceMaps: function _resolveSourceMaps(bundle) {
    var _this7 = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9() {
      var rawSourceMap, mapping, rangesInSourceFiles;
      return _regenerator["default"].wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return _this7._getSourcemapForFileAtUrl(bundle.url);
            case 2:
              rawSourceMap = _context9.sent;
              if (!(rawSourceMap === undefined)) {
                _context9.next = 5;
                break;
              }
              return _context9.abrupt("return", undefined);
            case 5:
              _context9.next = 7;
              return new _sourceMap["default"].SourceMapConsumer(rawSourceMap);
            case 7:
              mapping = _context9.sent;
              rangesInSourceFiles = bundle.ranges.map(function (range) {
                return _this7._resolveRange(range, bundle.text, mapping);
              }).filter(_this7._isDefined);
              return _context9.abrupt("return", rangesInSourceFiles);
            case 10:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }))();
  },
  /**
   * @template T
   * @param {T | undefined} value 
   * @returns {value is T}
   */
  _isDefined: function _isDefined(value) {
    if (value === undefined) return false;
    return true;
  },
  /**
   * 
   * @param {{start: number, end: number}} range 
   * @param {string} text 
   * @param {sourcemap.BasicSourceMapConsumer | sourcemap.IndexedSourceMapConsumer} mapping 
   * @returns {puppeteer.CoverageEntry}
   */
  _resolveRange: function _resolveRange(range, text, mapping) {
    var _original$start$colum, _original$start$line, _ref6, _original$start$sourc, _original$start$name, _original$end$column, _original$end$line, _ref7, _original$end$source, _original$end$name, _mapping$sourceConten, _mapping$sourceConten2, _mapping$sourceConten3;
    var consumableRange = {
      start: this._lineColFromPos(range.start, text),
      end: this._lineColFromPos(range.end, text)
    };

    // this is the problematic section.
    // originalPositionFor does not find positions for all given positions.
    // This is also tricky for ranges that span multiple files.
    var original = {
      start: mapping.originalPositionFor(_objectSpread(_objectSpread({}, consumableRange.start), {}, {
        bias: _sourceMap.SourceMapConsumer.GREATEST_LOWER_BOUND
      })),
      end: mapping.originalPositionFor(_objectSpread(_objectSpread({}, consumableRange.end), {}, {
        bias: _sourceMap.SourceMapConsumer.GREATEST_LOWER_BOUND
      }))
    };
    var originalNonNull = {
      start: {
        column: ((_original$start$colum = original.start.column) !== null && _original$start$colum !== void 0 ? _original$start$colum : 0) + 1,
        line: (_original$start$line = original.start.line) !== null && _original$start$line !== void 0 ? _original$start$line : 1,
        source: (_ref6 = (_original$start$sourc = original.start.source) !== null && _original$start$sourc !== void 0 ? _original$start$sourc : original.end.source) !== null && _ref6 !== void 0 ? _ref6 : '',
        name: (_original$start$name = original.start.name) !== null && _original$start$name !== void 0 ? _original$start$name : ''
      },
      end: {
        column: ((_original$end$column = original.end.column) !== null && _original$end$column !== void 0 ? _original$end$column : 0) + 1,
        line: (_original$end$line = original.end.line) !== null && _original$end$line !== void 0 ? _original$end$line : 1,
        source: (_ref7 = (_original$end$source = original.end.source) !== null && _original$end$source !== void 0 ? _original$end$source : original.start.source) !== null && _ref7 !== void 0 ? _ref7 : '',
        name: (_original$end$name = original.end.name) !== null && _original$end$name !== void 0 ? _original$end$name : ''
      }
    };
    var returnableRange = {
      start: this._posFromLineCol(originalNonNull.start, originalNonNull.start.source ? (_mapping$sourceConten = mapping.sourceContentFor(originalNonNull.start.source)) !== null && _mapping$sourceConten !== void 0 ? _mapping$sourceConten : undefined : undefined),
      end: this._posFromLineCol(originalNonNull.end, originalNonNull.end.source ? (_mapping$sourceConten2 = mapping.sourceContentFor(originalNonNull.end.source)) !== null && _mapping$sourceConten2 !== void 0 ? _mapping$sourceConten2 : undefined : undefined)
    };
    var entry = {
      text: originalNonNull.start.source ? (_mapping$sourceConten3 = mapping.sourceContentFor(originalNonNull.start.source)) !== null && _mapping$sourceConten3 !== void 0 ? _mapping$sourceConten3 : '' : '',
      url: originalNonNull.start.source,
      ranges: [returnableRange]
    };
    return entry;
  },
  _countInString: function _countInString() {
    var _char = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var ctr = 0;
    for (var i = 0; i < text.length; i++) {
      var currentChar = text[i];
      if (currentChar === _char) ctr++;
    }
    return ctr;
  },
  _nthIndexOf: function _nthIndexOf() {
    var _char2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var ctr = -1;
    for (var i = 0; i < text.length; i++) {
      var currentChar = text[i];
      if (currentChar === _char2) ctr++;
      if (ctr === n) return i;
    }
    return -1;
  },
  _lineColFromPos: function _lineColFromPos() {
    var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var textBeforePos = text.slice(0, pos);
    var line = this._countInString('\n', textBeforePos);
    var posOfLastLine = textBeforePos.lastIndexOf('\n') + 1;
    var textInLine = text.slice(posOfLastLine, pos);
    var column = textInLine.length;
    return {
      line: line + 1,
      column: column + 1
    };
  },
  _posFromLineCol: function _posFromLineCol(_ref8) {
    var _ref8$line = _ref8.line,
      line = _ref8$line === void 0 ? 1 : _ref8$line,
      _ref8$column = _ref8.column,
      column = _ref8$column === void 0 ? 1 : _ref8$column;
    var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    line--;
    column--;
    var newLine = '\n';
    var indexOfLine = line === 0 ? 0 : this._nthIndexOf(newLine, line - 1, text) + 1;
    var rest = text.substring(indexOfLine, indexOfLine + column);
    return indexOfLine + rest.length;
  },
  /**
  * @param {string} url
  */
  _getSourcemapForFileAtUrl: function _getSourcemapForFileAtUrl(url) {
    var _this8 = this;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10() {
      var originalFile, mark, indexOfMark, startOfMark, endOfMark, srcFileName, sourceMapName, sourceMapUrl;
      return _regenerator["default"].wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return _this8._fetchFileFromUrl(url);
            case 2:
              originalFile = _context10.sent.body;
              // we only care for the last mark
              mark = '//# sourceMappingURL=';
              indexOfMark = originalFile.lastIndexOf(mark);
              if (!(indexOfMark === -1)) {
                _context10.next = 7;
                break;
              }
              return _context10.abrupt("return", undefined);
            case 7:
              startOfMark = indexOfMark + mark.length;
              endOfMark = originalFile.indexOf('.map', startOfMark);
              srcFileName = originalFile.slice(startOfMark, endOfMark);
              sourceMapName = srcFileName + '.map';
              sourceMapUrl = url.replace(srcFileName, sourceMapName);
              _context10.next = 14;
              return _this8._fetchFileFromUrl(sourceMapUrl);
            case 14:
              return _context10.abrupt("return", _context10.sent.body);
            case 15:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }))();
  },
  /**
  * @param {string} url 
  * @returns {Promise<{meta: any, body: string}>}
  */
  _fetchFileFromUrl: function _fetchFileFromUrl(url) {
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11() {
      return _regenerator["default"].wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              return _context11.abrupt("return", new Promise(function (resolve, reject) {
                //@ts-ignore
                (0, _fetch.fetchUrl)(url, {}, function (error, meta, body) {
                  if (error) return reject(error);
                  return resolve({
                    meta: meta,
                    body: body.toString()
                  });
                });
              }));
            case 1:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }))();
  }
};
exports["default"] = _default;
module.exports = exports.default;